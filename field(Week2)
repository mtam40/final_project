int size, w, h;
int spd = 10;
int spawnspd = 100;
int fireSpd = 50;
//int waveChange = 200000; // future feature, once functionalities are working
PVector pos, dir = new PVector(0,0);
PVector playerBulletsDir = new PVector(0, -10);
ArrayList<PVector> playerBullets = new ArrayList<PVector>();
entity player = new entity();
ArrayList<PVector> enemyposList = new ArrayList<PVector>();
ArrayList<Enemy> enemyList = new ArrayList<Enemy>();
ArrayList<PVector> enemyBullets = new ArrayList<PVector>();
PVector enemyBulletsDir = new PVector(0, 2.5);
Enemy basic = new Enemy();

void setup() {
  size(1080, 700);
  size = 40;
  w = width/size;
  h = height/size;
  pos = new PVector(width / 2 / size * size, height / 2 / size * size); //initial position
  drawPlayer();
  player = new Player(size, 5, (int) pos.x, (int) pos.y);
  //noStroke();
  //fill(0);
  createBasics();
  enemyList.add(basic);
}

void draw() {
  background(200);
  grid();
  drawPlayer();
  if(frameCount % spd == 0) {
    updatePlayer();
    updateEnemies();
    collisionCheck();
  }
  if(frameCount % fireSpd == 0){
    createEnemyBullet(); 
  }
  if(frameCount % spawnspd == 0) {
    createBasics();
    //playerIsHit();//test gameOver
  }
  drawEnemies();
  updatePlayerBullets();
  updateEnemyBullets();
  gameOver();
}


void drawPlayer() {
  fill(#74FF83);
  square(pos.x, pos.y, size);
}

void updatePlayer(){
  pos.add(dir);
  fill(#74FF83);
  square(pos.x, pos.y, size);
  createPlayerBullet();
}

void createPlayerBullet(){
  PVector playerBulletl = new PVector(pos.x, pos.y);
  PVector playerBulletr = new PVector(pos.x + 25, pos.y);
  playerBullets.add(playerBulletl);
  playerBullets.add(playerBulletr);
  fill(#C45D5D);
  square(playerBulletl.x, playerBulletl.y, 15);
  square(playerBulletr.x, playerBulletr.y, 15);
}

void updatePlayerBullets(){
  for(int i = 0; i < playerBullets.size(); i++){
    if(playerBullets.get(i).y > 0){
      playerBullets.get(i).add(playerBulletsDir);
      fill(#C45D5D);
      square(playerBullets.get(i).x, playerBullets.get(i).y, 15);
    }
    else{playerBullets.remove(i);}
  }
} 

void grid() {
    for(int outer = 0; outer < h; outer++){
      for(int inner = 0; inner < w; inner++){
        fill(#FFFFFF);
        square( inner * size, outer * size, size);
      }
    }
}

void collisionCheck(){// enemyDamaged not working
 for(int i = 0; i < playerBullets.size(); i++){
   for(int j = 0; j < enemyposList.size(); j++){
     if((playerBullets.get(i).x == enemyposList.get(j).x ) &&
     (playerBullets.get(i).y == enemyposList.get(j).y )){
      // enemyList.get(i).set(enemyDamaged(enemyList.get(j)));
     }
   }
 }
 for(int i = 0; i < enemyBullets.size() ; i++){
     if((enemyBullets.get(i).x == pos.x ) &&
     (enemyBullets.get(i).x == pos.y)){
       playerIsHit();
       gameOver();
     }
   }
 }
 
void playerIsHit(){
   player = new Player(size, player.durability - 1, (int) pos.x, (int) pos.y);
}

void gameOver(){
 if (player.durability < 1){
   fill(#030303);
   rect(0, 0, 1080, 720);//dummy "Game Over"
 }
}
void keyPressed() {
  if(key == CODED) {
    if(keyCode == UP) { dir = new PVector(0, -size); }
    if(keyCode == DOWN) { dir = new PVector(0, size); }
    if(keyCode == LEFT) { dir = new PVector(-size, 0); }
    if(keyCode == RIGHT) { dir = new PVector(size, 0); }
    if(keyCode == SHIFT) { dir = new PVector(0, 0); }
  } 
}

//pure testing
void createBasics(){
  Enemy basic = new Enemy(40, 40, "basicEnemy", 5, (int) random(width) / size * size, (int) random(height / 3) / size * size);
  PVector basicEnemy = new PVector(basic.xcord, basic.ycord);
  fill(#3F4067);
  square(basicEnemy.x, basicEnemy.y, 40);
  enemyList.add(basic);
  enemyposList.add(basicEnemy);
}

void drawEnemies(){
 for(int i = 0; i < enemyposList.size(); i++){
    fill(#3F4067);
    square(enemyposList.get(i).x, enemyposList.get(i).y, size);
  } 
}

void updateEnemies(){
  for(int i = 0; i < enemyposList.size(); i++){
    enemyposList.get(i).add(0.0, (float) enemyList.get(i).spd);
    /*enemyList.get(i).set(
    new Enemy(enemyList.get(i).size, enemyList.get(i).durability, enemyList.get(i).type, 
    enemyList.get(i).spd, enemyposList.get(i).x, enemyposList.get(i).y)
    );*/
  }
} 

void createEnemyBullet(){
  for(int i = 0; i < enemyposList.size(); i++){
     PVector enemyBullet = new PVector(enemyposList.get(i).x, enemyposList.get(i).y);
     enemyBullets.add(enemyBullet);
     fill(#FA1414);
     square(enemyBullet.x, enemyBullet.y, 40); 
  }
}

void updateEnemyBullets(){
  for(int i = 0; i < enemyBullets.size(); i++){
    if(enemyBullets.get(i).y < height){
    enemyBullets.get(i).add(enemyBulletsDir);
    fill(#FA1414);
    square(enemyBullets.get(i).x, enemyBullets.get(i).y, 40);
    }
    else{enemyBullets.remove(i);}
  }
} 

/*
Enemy enemyDamaged(Enemy object){
   return new Enemy(object.size, object.durability - 1, object.type, object.spd, object.xcord, object.ycord);
}
*/
